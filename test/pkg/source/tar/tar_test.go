package tar_test

import (
	"bytes"
	"context"
	"crypto/md5"
	"fmt"
	"io"
	"os"
	"testing"

	"github.com/mittwald/brudi/pkg/source"
	commons "github.com/mittwald/brudi/test/pkg/source/internal"

	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/suite"
	"gotest.tools/assert"
)

const backupPath = "../../../testdata/tarTestFile.yaml"
const targetPath = "/tmp/tarTestFile.yaml.tar.gz"
const extractedPath = "/tmp/testdata/tarTestFile.yaml"

type TarTestSuite struct {
	suite.Suite
	resticExists bool
}

func (tarTestSuite *TarTestSuite) SetupTest() {
	commons.TestSetup()
}

// TearDownTest resets viper after a test
func (tarTestSuite *TarTestSuite) TearDownTest() {
	viper.Reset()
}

// TestBasicTarDump tests brudi's tar compression and extraction functions
func (tarTestSuite *TarTestSuite) TestBasicTarDump() {
	ctx := context.Background()

	defer func() {
		targetErr := os.Remove(targetPath)
		if targetErr != nil {
			log.WithError(targetErr).Error("failed to delete targetPath while testing tar")
		}
	}()

	defer func() {
		extractedErr := os.Remove(extractedPath)
		if extractedErr != nil {
			log.WithError(extractedErr).Error("failed to delete extractedPath while testing tar")
		}
	}()

	tarConfig := createTarConfig()
	err := viper.ReadConfig(bytes.NewBuffer(tarConfig))
	tarTestSuite.Require().NoError(err)

	var initialHash string
	initialHash, err = tarDoBackup(ctx)
	tarTestSuite.Require().NoError(err)

	var restoredHash string
	restoredHash, err = tarDoRestore(ctx)
	tarTestSuite.Require().NoError(err)

	assert.Equal(tarTestSuite.T(), initialHash, restoredHash)
}

func TestTarTestSuite(t *testing.T) {
	_, resticExists := commons.CheckProgramsAndRestic(t, "tar", "--version")
	testSuite := &TarTestSuite{
		resticExists: resticExists,
	}
	suite.Run(t, testSuite)
}

// tarDoBackup uses brudi to compress a test file into a tar.gz archive and returns the uncompressed files md5 hash
func tarDoBackup(ctx context.Context) (string, error) {
	hash, err := hashFile(backupPath)
	err = source.DoBackupForKind(ctx, "tar", false, false, false, false)
	if err != nil {
		return "", err
	}

	return hash, nil
}

// tarDoRestore uses brudi to restore a backup from tar and returns its md5 checksum for verification
func tarDoRestore(ctx context.Context) (string, error) {
	err := source.DoRestoreForKind(ctx, "tarrestore", false, false)
	if err != nil {
		return "", err
	}
	var hash string
	hash, err = hashFile(extractedPath)
	if err != nil {
		return "", err
	}
	return hash, nil
}

// hashFile calculates the md5 hash of the given file
func hashFile(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", errors.WithStack(err)
	}
	defer func() {
		fileErr := file.Close()
		if fileErr != nil {
			log.WithError(fileErr).Error("failed to close file from hash generation")
		}
	}()

	hash := md5.New()
	_, err = io.Copy(hash, file)
	if err != nil {
		return "", errors.WithStack(err)
	}
	return string(hash.Sum(nil)), nil
}

// createTarConfig creates a brudi config for the tar commands
func createTarConfig() []byte {
	//restoreTarget := "/tmp"
	/*stdinFilename := ""
	if doStdinBackup {
		stdinFilename = fmt.Sprintf("        backup:\n          flags:\n            stdinFilename: %s\n",
			backupPath)
		//restoreTarget = path.Join(restoreTarget, targetPath)
	}*/
	return []byte(fmt.Sprintf(
		//doPipingBackup: %t
		`
tar:
  options:
    flags:
      create: true
      gzip: true
      file: %s
    additionalArgs: []
    paths: 
      - %s
    hostName: autoGeneratedIfEmpty
tarrestore:
  options:
    flags:
      extract: true
      gzip: true
      file: %s
      target: "/tmp"
    additionalArgs: []
  hostName: autoGeneratedIfEmpty
`, targetPath, backupPath, targetPath,
	))
}
